name: YAML Guard

on:
  pull_request:
    paths:
      - '**/*.yml'
      - '**/*.yaml'
      - '.pre-commit-config.yaml'
  push:
    branches: [ main ]
    paths:
      - '**/*.yml'
      - '**/*.yaml'
      - '.pre-commit-config.yaml'

jobs:
  precommit:
    name: Pre-commit (YAML Guard hooks)
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install project + pre-commit
        run: |
          python -m pip install --upgrade pip
          pip install -e .[dev]
          pip install pre-commit
      - name: Run pre-commit on all files
        run: |
          pre-commit run --all-files

  guard:
    name: YAML Guard (annotations + PR comment)
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write   # needed to post PR comments with GITHUB_TOKEN

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install project
        run: |
          python -m pip install --upgrade pip
          pip install -e .[dev]

      # Run YAML Guard twice (K8s + Secrets), capture JSON, and merge
      - name: Run YAML Guard and collect findings
        run: |
          set -e
          python - <<'PY'
          import json, subprocess

          def run(cmd):
              p = subprocess.run(cmd, text=True, capture_output=True)
              print(p.stdout)               # keep CLI output
              if p.returncode not in (0,1,2):  # our CLI exits 1 on findings, 2 on parse errs
                  raise SystemExit(p.returncode)
              return json.loads(p.stdout or '{"ok":true,"findings":[]}')

          a = run(["yamlguard","**/*.y*ml","--rules","policies/k8s/core.yaml"])
          b = run(["yamlguard","**/*.y*ml","--rules","policies/security/secrets.yaml"])

          findings = (a.get("findings", []) + b.get("findings", []))
          with open("findings.json","w",encoding="utf-8") as f:
              json.dump({"findings": findings}, f, ensure_ascii=False)
          PY

      # Emit GitHub Annotations + Step Summary, and expose an output if findings exist
      - name: Annotate & summarize
        id: annotate
        if: always()
        run: |
          python - <<'PY'
          import json, os, sys
          data = json.load(open("findings.json", encoding="utf-8"))
          fins = data.get("findings", [])

          # GitHub Annotations
          for x in fins:
              sev = (x.get("severity","") or "").lower()
              level = "error" if sev in ("high","critical") else "warning"
              msg = f"[{x.get('severity','').upper()}] {x.get('rule_id','')}: {x.get('message','')}"
              file = x.get("file","")
              line = x.get("line")
              if file:
                  if line:
                      print(f"::{level} file={file},line={line}::{msg}")
                  else:
                      print(f"::{level} file={file}::{msg}")
              else:
                  print(f"::{level}::{msg}")

          # Step summary
          summary_path = os.environ.get("GITHUB_STEP_SUMMARY")
          if summary_path:
              with open(summary_path, "a", encoding="utf-8") as s:
                  if not fins:
                      s.write("### YAML Guard: no findings ✅\n")
                  else:
                      s.write(f"### YAML Guard: {len(fins)} finding(s) ❌\n\n")
                      for x in fins:
                          loc = (x.get("file","") or "")
                          if x.get("line"):
                              loc += f":{x['line']}"
                          s.write(f"- **{x.get('severity','')}** `{x.get('rule_id','')}` — {x.get('message','')}\n")
                          if loc:
                              s.write(f"  \n  `{loc}`\n")
                          snip = x.get("snippet")
                          if snip:
                              s.write(f"  \n```yaml\n{snip}\n```\n")

          # Output flag for next step
          if fins:
              with open(os.environ["GITHUB_OUTPUT"], "a", encoding="utf-8") as out:
                  out.write("has_findings=true\n")
          PY

      # Post a PR comment with a readable, condensed report
      - name: Comment on PR
        if: github.event_name == 'pull_request' && steps.annotate.outputs.has_findings == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const data = JSON.parse(fs.readFileSync('findings.json','utf8'));
            const fins = data.findings || [];
            if (fins.length === 0) {
              core.info('No findings; skipping PR comment.');
              return;
            }
            const capped = fins.slice(0, 50); // keep comments tidy
            const lines = [];
            lines.push(`### YAML Guard found **${fins.length}** issue(s) ❌`);
            lines.push('');
            for (const x of capped) {
              const sev = (x.severity || '').toUpperCase();
              const rid = x.rule_id || '';
              const msg = x.message || '';
              let loc = x.file || '';
              if (x.line) loc += `:${x.line}`;
              lines.push(`- **${sev}** \`${rid}\` — ${msg}`);
              if (loc) lines.push(`  \n  \`${loc}\``);
              if (x.snippet) lines.push(`\n  \n\`\`\`yaml\n${x.snippet}\n\`\`\``);
            }
            if (fins.length > 50) lines.push(`\n… and **${fins.length - 50}** more.`);
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              body: lines.join('\n')
            });

      # Finally: fail the job if there are findings
      - name: Fail if findings exist
        if: steps.annotate.outputs.has_findings == 'true'
        run: exit 1
